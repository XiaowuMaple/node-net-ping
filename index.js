
var events = require ("events");
var net = require ("net");
var raw = require ("raw-socket");
var util = require ("util");

function RequestTimedOutError (message) {
	this.name = "RequestTimedOutError";
	this.message = message;
}
util.inherits (RequestTimedOutError, Error);

function Session (options) {
	this.retries = (options && options.retries) ? options.retries : 1;
	this.timeout = (options && options.timeout) ? options.timeout : 2000;
	
	this.socket = null;
	
	this.reqs = {};
	this.reqsPending = 0;
	
	this.getSocket ();
};

util.inherits (Session, events.EventEmitter);

Session.prototype.close = function () {
	if (this.socket)
		this.socket.close ();
	this.flush (new Error ("Socket forcibly closed"));
};

Session.prototype.flush = function (error) {
	for (id in this.reqs) {
		var req = this.reqRemove (id);
		req.callback (error, req.target, false);
	}
};

Session.prototype.getSocket = function () {
	if (this.socket)
		return this.socket;
	var me = this;
	var options = {
		protocol: raw.Protocol.ICMP,
		generateChecksums: true,
		checksumOffset: 2
	};
	this.socket = raw.createSocket (options);
	this.socket.on ("close", this.onSocketClose.bind (me));
	this.socket.on ("error", this.onSocketError.bind (me));
	this.socket.on ("message", this.onSocketMessage.bind (me));
	return this.socket;
};

Session.prototype.fromBuffer = function (buffer) {	
	// IP header too short
	if (buffer.length < 20)
		return;
	
	// IPv4 only
	if ((buffer[0] & 0xf0) != 0x40)
		return;
	
	var ip_length = (buffer[0] & 0x0f) * 4;
	
	// ICMP message too short
	if (buffer.length - ip_length < 8)
		return;

	var id = buffer.readUInt16BE (ip_length + 4);	
	var req = this.reqs[id];
	
	if (req) {
		req.type = buffer.readUInt8 (ip_length);
		req.code = buffer.readUInt8 (ip_length + 1);

		return req;
	} else {
		return null;
	}
};

Session.prototype.onSocketClose = function () {
	this.emit ("close");
	this.flush (new Error ("Socket closed"));
};

Session.prototype.onSocketError = function (error) {
	this.emit ("error", error);
};

Session.prototype.onSocketMessage = function (buffer, source) {
	var req = this.fromBuffer (buffer);
	if (req) {
		if (req.type == 0) {
			req.callback (null, req.target);
		} else if (req.type == 3) {
			req.callback (new Error ("Destination unreachable"), req.target);
		} else if (req.type == 4) {
			req.callback (new Error ("Source quench"), req.target);
		} else if (req.type == 5) {
			req.callback (new Error ("Redirect received"), req.target);
		} else if (req.type == 11) {
			req.callback (new Error ("Time exceeded"), req.target);
		} else {
			req.callback (new Error ("Unknown response type '" + req.type + "'"),
					source);
		}
		this.reqRemove (req.id);
	}
};

Session.prototype.onSocketSend = function (req, error, bytes) {
	if (error) {
		req.callback (error, req.target);
		this.reqRemove (req.id);
	} else {
		var me = this;
		req.timer = setTimeout (this.onTimeout.bind (me, req), req.timeout);
	}
};

Session.prototype.onTimeout = function (req) {
	if (req.retries > 0) {
		req.retries--;
		this.send (req);
	} else {
		req.callback (new RequestTimedOutError ("Request timed out"),
				req.target);
		this.reqRemove (req.id);
	}
};

var nextId = 1;

function _generateId () {
	return nextId++;
}

Session.prototype.pingHost = function (target, callback) {
	var req = {
		id: _generateId (),
		seq: 1,
		retries: this.retries,
		timeout: this.timeout,
		callback: callback,
		target: target
	};
	req.buffer = this.toBuffer (req);
	
	this.reqs[req.id] = req;
	this.reqsPending++;
	this.send (req);
};

Session.prototype.reqRemove = function (id) {
	var req = this.reqs[id];
	if (req) {
		clearTimeout (req.timer);
		delete req.timer;
		delete this.reqs[req.id];
		this.reqsPending--;
	}
	if (this.reqsPending <= 0)
		this.close ();
	return req;
};

Session.prototype.send = function (req) {
	var buffer = req.buffer;
	var me = this;
	this.getSocket ().send (buffer, 0, buffer.length, req.target,
			this.onSocketSend.bind (me, req));
};

Session.prototype.toBuffer = function (req) {
	var buffer = new Buffer (16);
	
	buffer.writeUInt8 (8, 0);
	buffer.writeUInt8 (0, 1);
	buffer.writeUInt16BE (0, 2);
	buffer.writeUInt16BE (req.id, 4);
	buffer.writeUInt16BE (req.seq++, 6);
	
	// Checksums are be generated by our raw.Socket instance
	
	return buffer;
};

exports.createSession = function (options) {
	return new Session (options || {});
};

exports.Session = Session;

exports.RequestTimedOutError = RequestTimedOutError;
